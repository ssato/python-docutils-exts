#! /usr/bin/python -tt
#
# Author: Satoru SATOH <ssato redhat.com>
# License: MIT
#
"""
Bootstrap files to process them with rst2{odt,pdf}-wrapper.
"""
from __future__ import print_function

import argparse
import datetime
import glob
import logging
import os.path
import os
import pprint
import random
import shutil
import sys

import anyconfig
import anyconfig.compat  # TODO
import anytemplate


# SEE build.sh:
__version__ = "0.1.1"
TEMPLATE_PATH = "/usr/share/rst2odt/templates"
TEMPLATE_EXT = ".j2"

LOG = logging.getLogger("docutils-exts-bootstrap")
LOG.addHandler(anyconfig.compat.NullHandler())
LOG.setLevel(logging.INFO)

ALOG = logging.getLogger("anyconfig")
ALOG.setLevel(logging.INFO)


def sglob(files_pattern):
    """
    sorted + glob.glob.
    """
    return sorted(glob.glob(files_pattern))


def _to_relpath(path, destdir):
    """
    >>> _to_relpath("/a/b/c/d/e", "/a/b/c")
    'd/e'
    >>> _to_relpath("/a/b/c/d/e", "/a/b/c/")
    'd/e'
    >>> _to_relpath("/a/b/c/d/e", "/a/b/d")
    None
    """
    if not path.startswith(destdir):
        LOG.warn("The {} does not start with {}".format(path, destdir))
        return None

    return path.replace(destdir if destdir.endswith('/') else destdir + '/',
                        '')


def _tmpl_to_outpath(path, destdir):
    """
    >>> _tmpl_to_outpath('/a/b/c/d/e.rst.j2', '/a/b/c')
    'd/e.rst'
    """
    relpath = _to_relpath(path, destdir)
    if relpath is None:
        return None

    (fn, _fext) = os.path.splitext(relpath)
    return fn


def render_template(tmpl_path, destdir, workdir, ctx=None, engine=None,
                    force=False):
    """
    Render given template file ``tmpl_path`` with given context ``ctx`` and
    dump into the file under ``workdir`` with template file path relative to
    ``destdir`` kept.

    :param tmpl_path: Template file path
    :param destdir: Template top dir to strip from ``tmpl_path``
    :param workdir: Working dir to save compiled results
    :param ctx: Context dictionary to instantiate given template
    :param engine: Template engine to render template files
    :param force: Force overwrite outputs even if these already exist if True
    """
    tmpl_path = os.path.abspath(tmpl_path)
    outpath = os.path.join(workdir, _tmpl_to_outpath(tmpl_path, destdir))
    tpaths = [os.path.dirname(tmpl_path), os.curdir]

    if os.path.exists(outpath):
        if force:
            os.rename(outpath, outpath + '~')
        else:
            LOG.info("{} already exists. Skip it...".format(outpath))
            return

    LOG.debug("Compile the template {} to {}".format(tmpl_path, outpath))
    anytemplate.render_to(tmpl_path, context=ctx, output=outpath,
                          at_paths=tpaths, at_engine=engine)


def ensure_dir_exists(outdir):
    """
    Ensure output dir exists.
    """
    if not os.path.exists(outdir):
        os.makedirs(outdir)


def _setup_file(path, destdir, workdir, ctx, render=False, engine=None,
                tmpl_ext=TEMPLATE_EXT, force=False):
    """
    Setup a file.
    """
    if path.endswith(tmpl_ext):
        if render:
            render_template(path, destdir, workdir, ctx, engine, force)
        else:
            relpath = _to_relpath(path, destdir)
            dstdir = os.path.dirname(os.path.join(workdir, relpath))
            ensure_dir_exists(dstdir)
            LOG.debug("Copy template from %s to %s", path, dstdir)
            shutil.copy2(path, dstdir)
    else:
        relpath = _to_relpath(path, destdir)
        dst = os.path.join(workdir, relpath)

        if os.path.exists(dst):
            if force:
                os.rename(dst, dst + '~')
            else:
                LOG.info("{} already exists. Skip it...".format(dst))
                return

        dstdir = os.path.dirname(dst)
        ensure_dir_exists(dstdir)
        LOG.debug("Make a symlink from {} to {} (relpath)".format(path,
                                                                  relpath))
        os.symlink(path, dst)


def setup_files(destdir, workdir, ctx, render=False, engine=None,
                tmpl_ext=TEMPLATE_EXT, force=False):
    """
    Setup files.

    :param destdir: Template top dir to strip from ``tmpl_path``
    :param workdir: Working dir to save compiled results
    :param ctx: Context dictionary to instantiate given template
    :param render: Render template instead of copy if True
    :param engine: Template engine to render template files
    :param tmpl_ext: Jinja2 template file extension [.j2]
    :param force: Force overwrite outputs even if these already exist if True
    """
    for dirpath, dirnames, filenames in os.walk(destdir):
        for dn in dirnames:
            d = os.path.join(workdir, _to_relpath(os.path.join(dirpath, dn),
                                                  destdir))
            if not os.path.exists(d):
                os.makedirs(d)

        for fn in filenames:
            _setup_file(os.path.join(dirpath, fn), destdir, workdir, ctx,
                        render, engine, tmpl_ext, force)

def build_aux_file(workdir, ctx, out):
    tmpl = out + ".j2"
    if os.path.exists(tmpl):
        anytemplate.render_to(tmpl, context=ctx, output=out,
                              at_paths=[workdir], at_engine="jinja2")


TODAY = datetime.datetime.now().strftime("%Y%m%d")
DEFAULTS = dict(name=None, ctx=None, debug=False, force=False,
                workdir="/tmp/{}.{}".format(TODAY, random.randint(1, 10)),
                type="default", template_path=TEMPLATE_PATH, render=False,
                engine="jinja2")


def option_parser(defaults=DEFAULTS):
    """
    Make up an option and arguments parser.

    :param defaults: Default option values
    :param usage: Usage text
    """
    engines = [e.name() for e in anytemplate.engine.list_engines_by_priority()]
    ttypes = [os.path.basename(d) for d
              in sglob(os.path.join(TEMPLATE_PATH, '*')) if os.path.isdir(d)]

    psr = argparse.ArgumentParser()
    psr.set_defaults(**defaults)

    psr.add_argument("name", type=str, help="Document name")
    psr.add_argument("-w", "--workdir", help="Working dir [%(default)s]")
    psr.add_argument("-t", "--type", choices=ttypes,
                     help=("Template type [%%(default)s]: %s" % ttypes)),
    psr.add_argument("-T", "--template-path",
                     help="Template path [%(default)s]")
    psr.add_argument("-f", "--force", action="store_true",
                      help="Force overwrite outputs even if they exist")
    psr.add_argument("-C", "--ctx",
                     help="Specify file path to provides context data "
                          "to instantiate templates. The file must be"
                          "in YAML format")
    psr.add_argument("-R", "--render", action="store_true",
                     help="Render templates instead of copying templates")
    psr.add_argument("-E", "--engine", choices=engines,
                     help="Template engine name such as jinja2 [%(default)s]. "
                          "Choises: " + ", ".join(engines))
    psr.add_argument("-D", "--debug", action="store_true",
                      help="Debug (verbose) mode")
    return psr


def main(argv=sys.argv):
    """
    :param argv: Argument list to parse [sys.argv]
    """
    parser = option_parser()
    args = parser.parse_args(argv[1:])

    if not args or args.name is None:
        parser.print_usage()
        sys.exit(-1)

    doc_name = args.name
    tmpldir = os.path.join(args.template_path, args.type)

    if args.debug:
        LOG.setLevel(logging.DEBUG)
        ALOG.setLevel(logging.DEBUG)

    if not args.workdir:
        args.workdir = os.path.join(os.curdir, "workdir-" + args.type)

    if args.ctx:
        if '~' in args.ctx:
            args.ctx = os.path.expanduser(args.ctx)

        ctx = anyconfig.load(args.ctx, ac_template=True)
        for k, v in ctx.get("common", {}).items():
            ctx[k] = v  # Lift 'common' objects to top level.
    else:
        ctx = {}

    if "doc" not in ctx:
        ctx["doc"] = dict()

    if "name" not in ctx["doc"]:
        ctx["doc"]["name"] = doc_name

    if "revision" not in ctx["doc"]:
        ctx["doc"]["revision"] = "{}.1".format(TODAY)

    LOG.debug("ctx:\n" + pprint.pformat(ctx))

    if not os.path.exists(args.workdir):
        os.makedirs(args.workdir)

    setup_files(tmpldir, args.workdir, ctx, args.render, args.engine,
                TEMPLATE_EXT, args.force)
    build_aux_file(args.workdir, ctx, "ctx.yml")
    build_aux_file(args.workdir, ctx, "Makefile")

    LOG.info("Bootstrap done. Results in: %s", args.workdir)


if __name__ == '__main__':
    main(sys.argv)

# vim:sw=4:ts=4:et:
